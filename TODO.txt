# TODO List:
General:
    struct xyz  //type
    {
       float x,
       float y,
       float z
       ...
    };
    typedef struct xyz Position;
    
    struct pid_constants  //type
    {
       float kp,
       float ki,
       float kd,
       float min,
       float max
       ...
    };
    typedef struct pid_constants PidConstants;
    PidConstants kroll,kpitch,kyaw,kheight;
    
    kroll.kp=1.0;
    kroll.ki=0.0;
    kroll.kd=0.0;    
    kroll.min= motor_max-motor_start *  -0.1 ;
    kroll.max= motor_max-motor_start *   0.1 ;
    
    kpitch.kp=1.0;
    kpitch.ki=0.0;
    kpitch.kd=0.0;
    kpitch.min= motor_max-motor_start * -0.1 ;
    kpitch.max= motor_max-motor_start *  0.1 ;
    
    kyaw.kp=0.2;
    kyaw.ki=0.0;
    kyaw.kd=0.0;
    kyaw.min= motor_max-motor_start  *  -0.1 ;
    kyaw.max= motor_max-motor_start *  0.1 ;
    
    kheight.kp=1.0;
    kheight.ki=0.0;
    kheight.kd=0.0;    
    kheight.min= motor_max-motor_start *  -0.1 ;
    kheight.max= motor_max-motor_start *   0.1 ;
    
    struct throttle_container  //type
    {
       int fl,
       int fr,
       int bl,
       int br
       ...
    };
    typedef struct throttle_container ThrottleContainer;
    ThrottleContainer throttle;
    
    struct attitude  //type
    {
       float roll,
       float pitch,
       float yaw
       ...
    };
    typedef struct attitude Attitude;
    
    Attitude desired, measured, errorp, errord, errori;  //instantiate a struct of type record
    
    int idle =1;
    int flight =2;
    
    int flight_mode = idle;
    int motor_min= 900;
    int motor_start= 1000;
    int motor_max= 2000;
      Servo fl;
      Servo fr;
      Servo bl;
      Servo br;
      
      
   void get_pid_roll(){
        float result=0.0;      
       
        result+=kroll.kp*errorp.roll;//P
        result+=kroll.ki*errori.roll;//I
        result+=kroll.kd*errord.roll; //D
        
        if (result>=kroll.max){
            result=kroll.max;
            Serial.println("
        }
   
   }
    
    void setup_pid(void){
        errorp.roll=0.0;
        errorp.pitch=0.0;
        errorp.yaw=0.0;
        
        errori.roll=0.0;
        errori.pitch=0.0;
        errori.yaw=0.0;
        
        errord.roll=0.0;
        errord.pitch=0.0;
        errord.yaw=0.0;
        
        desired.roll=0.0;
        desired.pitch=0.0;
        desired.yaw=0.0;
        
        measured.roll=0.0;
        measured.pitch=0.0;
        measured.yaw=0.0;
    
    }
    
    void get_attitude_error(void){
        Attitude temp;        
        temp.roll=desired.roll-measured.roll;
        temp.pitch=desired.pitch-measured.pitch;
        temp.yaw=desired.yaw-measured.yaw;
        
       //D //must do this before P to get difference    
        errord.roll=temp.roll-errorp.roll;    //  missing divide by delta t (acount for this in kd 
        errord.pitch=temp.pitch-errorp.pitch;
        errord.yaw=temp.yaw-errorp.yaw;
        
        
        //I
        if (mode==flight){
            errori.roll+=temp.roll;
            errori.pitch+=temp.pitch;
            errori.yaw+=temp.yaw;
        }
        else{
            errori.roll=0.0;
            errori.pitch=0.0;
            errori.yaw=0.0;
        }
        
        //P        
        errorp.roll=temp.roll;
        errorp.pitch=temp.pitch;
        errorp.yaw=temp.yaw;
        
    }
    
    
    
    
    
    
    
    
    void setup_motors(void){
      fl.attach(fl_pin, motor_min, motor_max);
      fr.attach(fr_pin, motor_min, motor_max);
      bl.attach(bl_pin, motor_min, motor_max);
      br.attach(br_pin, motor_min, motor_max);
      
      if (!CALIBRATION_MODE){      
        fl.writeMicroseconds(motor_min);
        fr.writeMicroseconds(motor_min);
        bl.writeMicroseconds(motor_min);
        br.writeMicroseconds(motor_min);
      }
      
    }
    
    void cal_esc(void){
      Serial.flush();
      if (CALIBRATION_MODE){      
        fl.writeMicroseconds(motor_max);
        fr.writeMicroseconds(motor_max);
        bl.writeMicroseconds(motor_max);
        br.writeMicroseconds(motor_max);
      }
      Serial.println("plug in ESCs, beeps will increase in pitch, followed by a beep matching the pitch, press any key to continue...");
      while(!Serial.availiable());
      Serial.flush();
      
      int i;
      for(i=motor_max; i>=motor_min; i--){
        fl.writeMicroseconds(i);
        fr.writeMicroseconds(i);
        bl.writeMicroseconds(i);
        br.writeMicroseconds(i);
        delay(2);
      }
      
      Serial.println("Throtled down to the low end, two beeps of the same pitch should be emitted, press any key to cont");
      while(!Serial.availiable());
      Serial.flush();
      
      for(i=motor_min; i<=motor_start; i++){
        fl.writeMicroseconds(i);
        fr.writeMicroseconds(i);
        bl.writeMicroseconds(i);
        br.writeMicroseconds(i);
        delay(2);
      }
      
      Serial.println("Throtled up to start, three beeps should be emitted, press any key to cont");
      while(!Serial.availiable());
      Serial.flush();
    
    }
    
Calibration:
1
Set the radio throttle or servo tester to the highest position, then connect power to the ESC. The 
motor should produce a series of initialization beeps increasing in pitch, followed by another beep 
matching the pitch of the last initialization beep. This indicates that the calibration mode has been 
entered, and the pulse length has been learned.
2
Move the stick or knob to the lowest position. Two beeps of the same pitch should be emitted. This
indicates that the low pulse length has been learned. 
3
If the RC Car-style reversible mode has been 
enabled (RC_PULS_NEUTRAL), move the stick or knob to the center, and wait for three beeps. This 
indicates that the neutral (center) pulse length has been learned
  
  
  
Sensor(Embedded Software)
  -Tune Cfilter
  -Consider characterising the noise in each axis
  -Vibration testing/ re-tune when the PID works?
  -Consider Kalman Filter? -can probably steal from other repo
  -Pressure sensor
  -Include vector addition (i j k=rect, and mag, theta, phi)
  -integrate Z acc magnitude to get z velocity to help with height measurments
  -incorperate velocity and position tracking??
  - Flip roll b/c + = right wing down (roll to the right)
  - +pitch = front up
  
  
LIPO contol with MKR VIDOR
  -assess battery options?

CMND/STATUS (Embedded Software/ Ground Software)
    - get UDP to PC working. (bi-directional)  WIFI_NINA
    - try to make UDP faster and see if it is better than "client"
    
    add a function for easy JSON creation.

    -add failsafe for loosing connection/ corrupt data  (WATCHDOG for desired)
    
    - Side task: get a streaming ability to server mysql to capture timestamps and values.  Accept JSON in the following format?:
      {"time":,"telem":{"cx": , "cy":, "cz":, "dx":,"dy":,"dz":,"dt":...}}
         time(ms)   measured pos(deg),    desired pos(deg),   desired throtle(deg)
         Plot the MYSQL values>? need to make a db.
    
PWM (Embedded Software)
  -test arduino libraries with ESC 
  -test vidor output(5v pwm vs 3v3)!!
  -Create function/wrapper for writing to the ESCs
  -Create Calibrate ESC function
  
Flight Controller (Embedded Software)
  -Impliment PID Flight Controller (one per axis?)
  -esure KI windup cannot happen on the ground
  -Tune PID
  -add hover and killswitch
  
General (Embedded Software)
  -add failsafe for loosing connection/ corrupt data

Hardware
  -Use Protoboard
  -Buy headers (4x3PIN for ESCs), potentially more for redundancy, RC controller
  -Buy RC contoller
  -Mount the IMU on rubber onto the protoboard. Consider soldering in place to add mass and ruberixing the whole flight board?
  -Charge batteries
  -Add "RollCage" Before flight
  -Add "Killswitch" before flight (can be done in sw?)
  
  
  
  Done
    -Read Gyro/Accelerometer
  
    
  
  
  


